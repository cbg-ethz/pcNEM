color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="KEGG graph",col.main = "gray56")
plot(pcnem$graph,nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="pcNEM",col.main = "gray56")
plot(as(transitive.reduction(rnem$graph),"graphNEL"),nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="NEM",col.main = "gray56")
load("~/Downloads/BootstrapRes_withallGraphs_Pub_100.RData")
par(mfrow=c(1,3))
nodeLab <- c("ITGB1","FAK","PXN","RAC1","SRC","TLN1","VCL","CDC42")
names(nodeLab) <- nodes(pcnem$graph)
plot(as(Phi,"graphNEL"),nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="KEGG graph",col.main = "gray56")
plot(pcnem$graph,nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="pcNEM",col.main = "gray56")
plot(as(transitive.reduction(rnem$graph),"graphNEL"),nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="NEM",col.main = "gray56")
par(mfrow=c(1,3))
nodeLab <- c("ITGB1","FAK","PXN","RAC1","SRC","TLN1","VCL","CDC42")
names(nodeLab) <- nodes(pcnem$graph)
plot(as(Phi,"graphNEL"),nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="KEGG graph",col.main = "gray56")
plot(pcnem$graph,nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="pcNEM",col.main = "gray56")
plot(as(transitive.reduction(rnem$graph),"graphNEL"),nodeAttrs=list(label = nodeLab),
attrs=list(node=list(shape = "rectangle",
color="olivedrab3",
fontcolor="deepskyblue4",
fontsize=12),
edge=list(color="gray56")),main="NEM",col.main = "gray56")
load("~/Downloads/DiffThresh/BinData_Pub_critPval.Rdata")
load("~/Documents/ETH/MasterThesis/Plots/2016/24Nov2016/Summary_noiseEst.Rdata")
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/Plots/2017/21Sep2017/Summary_noiseEst_5to50.Rdata")
load("~/Documents/ETH/MasterThesis/Plots/2016/24Nov2016/Summary_noiseEst.Rdata")
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/Plots/2017/21Sep2017/Summary_noiseEst_5to50.Rdata")
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/Plots/2017/21Sep2017/NoiseEstimation120_Data_05to50320_TR_sf100.RData")
D <- Data[[69]]
KOmap <- knockout_map[[69]]
View(Idx)
KOmap <- knockout_map[[9]]
control$
vbgfh
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
#control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=TRUE)
control$map <- as.matrix(KOmap)
control$para
control$para <- Idx[69,c(2,3)]
control$para
control$para[1]
control$para[2]
control$para <- c(Idx[69,c(2,3)])
control$para[2]
control$para
res <- score(newNetsList[[9]],D,control,verbose)
res <- nem(D,models=list(newNetsList[[9]]),inference = "search",control = control)
res$mLL
res <- nem(D,models=list(transitive.closure(newNetsList[[9]])),inference = "search",control = control)
transitive.closure(newNetsList[[9]]))
transitive.closure(newNetsList[[9]])
transitive.closure(newNetsList[[9]],mat = TRUE,loops = FALSE)
res <- nem(D,models=list(transitive.closure(newNetsList[[9]],mat = TRUE,loops = FALSE)),inference = "search",control = control)
res$mLL
source('~/GitHub/c-NEMs/Package/pcnem/R/AdaSimulatedAnnealing.R')
source('~/GitHub/c-NEMs/Package/pcnem/R/pcNemFunctions.R')
a <- nem.AdaSA(8,newNetsList[[9]],D,control = )
a <- nem.AdaSA(8,newNetsList[[9]],D,control)
control$para
control$para <- c(0.13,0.05)
control$iterations <- 1e3
nem(D,models=list(newNetsList[[9]]),inference = "search",control = control)$mLL
-6791.878
a <- nem.AdaSA(8,newNetsList[[9]],D,control)
library(minqa)
a <- nem.AdaSA(8,newNetsList[[9]],D,control)
a$typeI
a$typeII
plot(as(a$graphs))
plot(as(a$maxDAG,"graphNEL"))
n = 8
Phi <- newNetsList[[9]]
chosenmove <- 1
noiseEst <- control$noiseEst
moveprobs <- control$moveprobs
moveprobsNoise <- control$moveprobsNoise
Sigma <- control$sigma
iterations <- control$iterations
stepsave <- control$stepsave
fan.in <- (n-1)
revallowed <- control$revallowed
if(is.null(control$AcceptRate)){ # ideal acceptance rate
AcceptRate <- 1/n
}else{
AcceptRate <- control$AcceptRate
}
Temp <- control$Temp
AdaptRate <- control$AdaptRate
Sgenes <- colnames(phi)
cmap <- 1-control$map # complementary probabilities
dimnames(cmap) <- dimnames(control$map)
nexp <- rownames(cmap) # number of experiments
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
currentAlpha <- control$para[1]
currentBeta <- control$para[2]
currentDAGParams <- DAGscore(PropMat,D1,D0,control,currentAlpha,currentBeta)
currentDAGlogscore <- currentDAGParams$mLL
currentDAGLMat <- currentDAGParams$LMat
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
D1 = sapply(nexp, function(s) rowSums(D[, colnames(D) == s, drop = FALSE])) # Signals present in the data
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1 # Signals absent in the data
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
source('~/GitHub/c-NEMs/Package/pcnem/R/pcNemFunctions.R')
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
phi <- Phi
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
bestScore <- currentDAGlogscore
bestGraph <- phi
bestPropMat <- PropMat
bestAlpha <- currentAlpha
bestBeta <- currentBeta
minSteps <- 0
currentAlpha <- 0.13
currentBeta <- 0.05
currentAlpha <- control$para[1]
currentBeta <- control$para[2]
currentDAGParams <- DAGscore(PropMat,D1,D0,control,currentAlpha,currentBeta)
currentDAGlogscore <- currentDAGParams$mLL
currentDAGLMat <- currentDAGParams$LMat
bestScore <- currentDAGlogscore
bestGraph <- phi
bestPropMat <- PropMat
bestAlpha <- currentAlpha
bestBeta <- currentBeta
minSteps <- 0
optimNoise <- function(x){
#-(DAGscore(bestPropMat,D1,D0,control,(exp(x[1]))/(1+exp(x[1])),(exp(x[2]))/(1+exp(x[2])))$mLL)
-(DAGscore(bestPropMat,D1,D0,control,x[1],x[2])$mLL)
}
NoiseEst <- bobyqa(c(bestAlpha, bestBeta), optimNoise, lower = c(1e-15, 1e-15), upper = c(0.5, 0.5))
NoiseEst
0.2365 0.0646
control$para <- c(0.23010,0.0742201)
res$mLL
nem(D,models=list(newNetsList[[9]]),inference = "search",control = control)$mLL
control$para <- c(0.2365,0.0646 )
nem(D,models=list(newNetsList[[9]]),inference = "search",control = control)$mLL
-6791.878 >-6790.756
-6791.878 < -6790.756
plot(as(Phi,"graphNEL"))
phi <- Phi
initPertMats <- getperturb.matrices(cmap,phi,control)
PropMat <- initPertMats$PropMat
#NoiseEst <- bobyqa(c(0.13, 0.05), optimNoise, lower = c(1e-15, 1e-15), upper = c(0.5, 0.5))
bestPropMat - PropMat
sum(bestPropMat - PropMat)
bobyqa(c(0.13, 0.05), optimNoise, lower = c(1e-15, 1e-15), upper = c(0.5, 0.5))
bobyqa(c(0.2365,0.0646), optimNoise, lower = c(1e-15, 1e-15), upper = c(0.5, 0.5))
control$para
DAGscore(bestPropMat,D1,D0,control,x[1],x[2])$mLL
DAGscore(bestPropMat,D1,D0,control,0.2365,0.0646)$mLL
DAGscore(bestPropMat,D1,D0,control,0.2365,0.0646)
DAGscore(bestPropMat,D1,D0,control,0.2365,0.0646)$mLL
source('~/GitHub/c-NEMs/Package/pcnem/R/mLL.R')
b <- mLL(Phi,D1,D0,control)
b$mLL
#nem(D,modelinference="search",control=control,verbose=FALSE)
control$para
control$para <- c(0.2365,0.0646)
nem(D,models=list(Phi),inference="search",control=control,verbose=FALSE)$mLL
a$maxLLscore
c <- nem.AdaSA(8,Phi,D,control)
c$maxLLscore
chosenmove <- 1
noiseEst <- control$noiseEst
moveprobs <- control$moveprobs
moveprobsNoise <- control$moveprobsNoise
Sigma <- control$sigma
iterations <- control$iterations
stepsave <- control$stepsave
fan.in <- (n-1)
revallowed <- control$revallowed
if(is.null(control$AcceptRate)){ # ideal acceptance rate
AcceptRate <- 1/n
}else{
AcceptRate <- control$AcceptRate
}
Temp <- control$Temp
AdaptRate <- control$AdaptRate
L1 <- list() # stores the adjecency matrices
L2 <- list() # stores the log likelihood score of the DAGs
L3 <- list() # stores the temperatures
L4 <- list() # stores the acceptance rates after 'stepsave' iterations
L5 <- list() # stores the alpha values
L6 <- list() # stores the beta values
transformAR <- log(0.5)/log(AcceptRate) # to make the ideal acceptance rate symmetrical i.e. AcceptRate^transformAR = 0.5
print(paste0("The exponent for the acceptance rate is ",transformAR))
# Initializing parameters
Sgenes <- colnames(phi)
cmap <- 1-control$map # complementary probabilities
dimnames(cmap) <- dimnames(control$map)
nexp <- rownames(cmap) # number of experiments
D1 = sapply(nexp, function(s) rowSums(D[, colnames(D) == s, drop = FALSE])) # Signals present in the data
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1 # Signals absent in the data
# For marginalizing the effects we use uniform priors across all Sgenes
if (is.null(control$Pe)) {
control$Pe <- matrix(1/n, nrow = nrow(D1), ncol = n)
colnames(control$Pe) <- Sgenes
}
if (control$selEGenes.method == "regularization" && ncol(control$Pe) == n) {
control$Pe = cbind(control$Pe, double(nrow(D1)))
control$Pe[, ncol(control$Pe)] = control$delta/n
control$Pe = control$Pe/rowSums(control$Pe)
}
initPertMats <- getperturb.matrices(cmap,phi,control) # To get initial propagation matrix and path count matrix
PropMat <- initPertMats$PropMat # Propagation matrix
PathMat <- initPertMats$PathMat # Path count matrix
currentAlpha <- control$para[1]
currentBeta <- control$para[2]
currentDAGParams <- DAGscore(PropMat,D1,D0,control,currentAlpha,currentBeta)
currentDAGlogscore <- currentDAGParams$mLL
currentDAGLMat <- currentDAGParams$LMat
L1 <- c(L1,list(phi)) # starting adjacency matrix
L2 <- c(L2,currentDAGlogscore) # starting DAG score
L3 <- c(L3,Temp) # starting temperature
L4 <- c(L4,0) # starting acceptance rate
L5 <- c(L5,currentAlpha) # starting alpha
L6 <- c(L6,currentBeta) # starting beta
AlphaChain <- NULL
BetaChain <- NULL
#sampled_alphachain <- NULL
#sampled_betachain <- NULL
bestScore <- currentDAGlogscore
bestGraph <- phi
bestPropMat <- PropMat
bestAlpha <- currentAlpha
bestBeta <- currentBeta
minSteps <- 0
DAGscore(bestPropMat,D1,D0,control,bestAlpha,bestBeta)$mLL
optimNoise <- function(x){
#-(DAGscore(bestPropMat,D1,D0,control,(exp(x[1]))/(1+exp(x[1])),(exp(x[2]))/(1+exp(x[2])))$mLL)
-(DAGscore(bestPropMat,D1,D0,control,x[1],x[2])$mLL)
}
optimNoise(control$para)
bobyqa(c(bestAlpha, bestBeta), optimNoise, lower = c(1e-15, 1e-15), upper = c(0.5, 0.5))
c$typeI
c$typeII
c$maxLLscore
View(Idx)
load("~/Documents/ETH/MasterThesis/Plots/2016/24Nov2016/Summary_noiseEst.Rdata")
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/Plots/2017/21Sep2017/Summary_noiseEst_5to50.Rdata")
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/Plots/2017/21Sep2017/NoiseEstimation120_Data_05to50320_TR_sf100.RData")
D <- Data[[1]]
KOmap <- knockout_map[[1]]
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
> #control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=TRUE)
> control$map <- as.matrix(KOmap)
> control$para
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
#control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=TRUE)
control$map <- as.matrix(KOmap)
control$para
control$para <- c(Idx[1,2],Idx[1,3])
control$para
Phi <- newNetsList[[1]]
nem(D,models = list(Phi),inference = "search",control=control)$mLL
source('~/GitHub/c-NEMs/Package/pcnem/R/AdaSimulatedAnnealing.R')
source('~/GitHub/c-NEMs/Package/pcnem/R/pcNemFunctions.R')
#a <- nem.AdaSA()
control$iterations <- 1e3
a <- nem.AdaSA(8,Phi,D,control)
a$maxLLscore
a$typeI
a$typeII
0.3640267 -0.3563
0.4653997-0.4544
load("/Volumes/beerenwinkel/ssumana/Documents/ETH/MasterThesis/data/singleCellFeatures/DataStorage/CriticalPval/RandKEGG/BugFixed7Sep2017/BinaryData_Wilcoxtest_critPval_RandKEGG.Rdata")
D <- Data[[1]]
KOmap <- knockout_map[[1]]
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 0
pcnem <- nem(D,models=list(netList[[1]]),inference="AdaSimAnneal",control=control,verbose=FALSE)
netList[[1]]
library(pcnem)
pcnem <- nem(D,models=list(netList[[1]]),inference="AdaSimAnneal",control=control,verbose=FALSE)
library(pcnem)
pcnem <- nem(D,models=list(netList[[1]]),inference="AdaSimAnneal",control=control,verbose=FALSE)
pcnem$mLL
load("~/Downloads/NoiseEstimation120_Data_05to50320_TR_sf100.RData")
D <- Data[[39]]
KOmap <- knockout_map[[9]]
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
#control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=TRUE)
control$map <- as.matrix(KOmap)
control$iterations <- 0
pcnem <- nem(D,models=list(netList[[9]]),inference="AdaSimAnneal",control=control,verbose=FALSE)
pcnem <- nem(D,models=list(newNetsList[[9]]),inference="AdaSimAnneal",control=control,verbose=FALSE)
pcnem$mLL
pcnem$typeIEst
pcnem$typeIIEst
View(Idx)
par(mfrow=c(1,2))
plot(as(newNetsList[[9]],"graphNEL"))
par(mfrow=c(1,2))
plot(as(newNetsList[[9]],"graphNEL"))
plot(pcnem$graph)
source('~/GitHub/c-NEMs/Package/pcnem/R/AdaSimulatedAnnealing.R')
source('~/GitHub/c-NEMs/Package/pcnem/R/pcNemFunctions.R')
a <- nem.AdaSA(8,newNetsList[[9]],D,control)
a$typeI
a$typeII
View(Idx)
a$maxLLscore
0.1297 - 0.13241
nem(D,models=list(newNetsList[[9]]),inference="search",control=control,verbose=FALSE)$mLL
control$para <- c(Idx[,2],Idx[,3])
nem(D,models=list(newNetsList[[9]]),inference="search",control=control,verbose=FALSE)$mLL
control$para <- c(Idx[39,2],Idx[39,3])
nem(D,models=list(newNetsList[[9]]),inference="search",control=control,verbose=FALSE)$mLL
pcnem$mLL
load("~/Downloads/NoiseEstimation120_5to50_320_TR_sf100_trueNet.RData")
source('~/GitHub/c-NEMs/Contc-NEMs/StructureMCMC/supplementaryfns.R')
summ_result <- NULL
for(j in 1:length(perfFinal)){#nrow(Idx)){
N <- 8
M <- length(epos)
uninfo = round(M*0.1)
epos <- effect_pos[[eseq]]
M <- length(epos)
uninfo = round(M*0.1)
Theta <- matrix(0, nrow=N, ncol=M)
for(l in 1:ncol(Theta)){
Theta[epos[l],l] <- 1
}
OnesandZeros <- NULL
typeI = Idx[j,2]
typeII = Idx[j,3]
for(i in 1:30){
temp <- genData(newNetsList[[i]],usedKOmap[[i]],Theta,uninfo,typeI,typeII)
OnesandZeros <- rbind(OnesandZeros,cbind(sum(temp),(prod(dim(temp))-sum(temp))))
}
avgOnes <- mean(OnesandZeros[,1])
avgZeros <-  mean(OnesandZeros[,2])
vartypeII <- sqrt(typeII*(1-typeII)/avgOnes)
vartypeI <- sqrt(typeI*(1-typeI)/avgZeros)
summ_result <- rbind(summ_result,cbind(typeI,typeII,
perfFinal[[j]]$pcnem$typeIEst,
perfFinal[[j]]$pcnem$typeIIEst,
avgOnes,avgZeros,vartypeI,vartypeII))
}
#colnames(summ_result) <- c("typeI","typeII","EstTypeI","EstTypeII","avgOnes","avgZeros","varTypeI","varTypeII")
rho_alpha <- cor.test(summ_result[,1], summ_result[,3], method = "spearman", alternative = "two.sided")
rho_beta <- cor.test(summ_result[,2], summ_result[,4], method = "spearman", alternative = "two.sided")
save(list=c("summ_result","rho_alpha","rho_beta"),file="~/Downloads/Summary_noiseEst_5to50_trueNet.Rdata")
summ_result_df <- data.frame(summ_result)
#summ_result_df <- cbind(summ_result_df,as.hexmode(round(255*(summ_result_df$typeI+summ_result_df$typeII),0)))
summ_result_df <- cbind(summ_result,summ_result_df$typeI+summ_result_df$typeII)
summ_result_df <- as.data.frame(summ_result_df)
colnames(summ_result_df) <- c("typeI","typeII","EstTypeI","EstTypeII","avgOnes","avgZeros","varTypeI","varTypeII","colour")
#col <- format(as.hexmode(-round(255*(summ_result_df$typeI+summ_result_df$typeII),0)),width=7) # Different colors for each point
# Vector of alphas and betas
pvec_alpha <- summ_result_df[,1]
pvec_beta <- summ_result_df[,2]
require(gridExtra)
# Colors for different points proportional to their corresponding alpha (beta) value
myPalette <- colorRampPalette(rev(brewer.pal(4, "Spectral")))
#sc <- scale_colour_gradientn(colours = myPalette(nrow(summ_result_df)), limits=c(0,1),name=paste0("\u03B1","+","\u03B2")) # for single legend
sc <- scale_colour_gradientn(colours = myPalette(nrow(summ_result_df)), limits=c(0,0.5),name=paste0("\u03B2"))
temp <- paste("rho == ", round(rho_alpha$estimate,3))
plot1 <- ggplot(summ_result_df, aes(typeI)) +
#geom_point(aes(y=EstTypeI,colour = summ_result_df$typeI + summ_result_df$typeII), shape=20,alpha=0.85) +  sc +
geom_point(aes(y=EstTypeI,colour = typeII), shape=20,alpha=0.85) +  sc +
geom_line(aes(y=typeI), colour="#7AA7BB") +#056F89,E14B5B,31BF63
geom_ribbon(aes(ymin=pvec_alpha - summ_result_df$varTypeI, ymax=pvec_alpha+summ_result_df$varTypeI),  fill = "#A3C4C9",alpha=0.34) +
geom_ribbon(aes(ymin=pvec_alpha-2*summ_result_df$varTypeI, ymax=pvec_alpha+2*summ_result_df$varTypeI), fill = "#A3C4C9",alpha=0.17) +
xlab(as.character("\u03B1")) +
ylab(expression(paste("MLE ","\u03B1"))) +
theme_bw()+
theme_bw()+
ylim(0,0.52)+
annotate("text", x = 0.07, y = 0.52, label = temp,parse=TRUE,color = "#525252",size = 5)+
theme(panel.grid.major= element_blank(),#element_line(linetype=5),
panel.grid.minor = element_blank(),
plot.margin = unit(c(0.5, 0.5, 0.35, 0.5), "cm"),
axis.ticks.x = element_line(size = 0.5,color="#525252"),
axis.text.y=element_text(angle=0, vjust=0.3, hjust=0.5,size=12,colour="#525252"),
axis.text.x=element_text(angle=0, vjust=0.5, hjust=0,size=12,colour="#525252"),
axis.title.x=element_text(angle=0,size=14,vjust=1,colour="#525252"),
axis.title.y=element_text(angle=90, size=14,face="bold",vjust=0,colour="#525252"),
legend.title = element_text(size=12.5,colour="#525252",angle=0),
legend.key.size = unit(.6, "cm"),
legend.key = element_blank(),
legend.title.align = 0.25,
legend.text= element_text(size=9,color="#525252",angle = 0))
sc <- scale_colour_gradientn(colours = myPalette(nrow(summ_result_df)), limits=c(0,0.5),name=paste0("\u03B1"))
temp <- paste("rho == ", round(rho_beta$estimate,3))
plot2 <- ggplot(summ_result_df, aes(typeII)) +
#geom_point(aes(y=EstTypeII,colour = summ_result_df$typeI + summ_result_df$typeII), shape=20,alpha=0.85) +  sc +
geom_point(aes(y=EstTypeII,colour = typeI), shape=20,alpha=0.85) +  sc +
geom_line(aes(y=typeII), colour="#7AA7BB") +#056F89,E14B5B
geom_ribbon(aes(ymin=pvec_beta+summ_result_df$varTypeII, ymax=pvec_beta-summ_result_df$varTypeII),  fill = "#A3C4C9",alpha=0.34) +#A16D8F,8BAFBE
geom_ribbon(aes(ymin=pvec_beta+2*summ_result_df$varTypeII, ymax=pvec_beta-2*summ_result_df$varTypeII), fill = "#A3C4C9",alpha=0.17)+
xlab("\u03B2") +
ylab(expression(paste("MLE ","\u03B2"))) +
theme_bw()+
ylim(0,0.52)+
annotate("text", x = 0.08, y = 0.52, label = temp,parse=TRUE,color = "#525252",size = 5)+
theme(panel.grid.major= element_blank(),#element_line(linetype=5),
panel.grid.minor = element_blank(),
plot.margin = unit(c(0.5, 0.5, 0.35, 0.5), "cm"),
axis.ticks.x = element_line(size = 0.5,color="#525252"),
axis.text.y=element_text(angle=0, vjust=0.3, hjust=0.5,size=12,colour="#525252"),
axis.text.x=element_text(angle=0, vjust=0.5, hjust=0,size=12,colour="#525252"),
axis.title.x=element_text(angle=0,size=14,vjust=1,colour="#525252"),
axis.title.y=element_text(angle=90, size=14,face="bold",vjust=0,colour="#525252"),
legend.title = element_text(size=12.5,colour="#525252",angle=0),
legend.key.size = unit(.6, "cm"),
legend.key = element_blank(),
legend.title.align = 0.25,
legend.text= element_text(size=9,color="#525252",angle = 0)) #77CBB9, 8BAD24,AAC128,#EF96A1
library(pcnem)
x = 97
Phi <- newNetsList[[x]]
Sgenes <- colnames(Phi)
D <- Data[[x]]
k <- Idx[x,1]
KOmap <- as(knockout_map[[k]],'matrix')
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- KOmap
control$iterations <- 0
pcnema <- nem(D,models=list(Phi),inference="AdaSimAnneal",control=control,verbose=FALSE)
startDAG
plot(as(startDAG,"graphNEL"))
plot(as(startDAG,"graphNEL"))
tempRes <- nem.AdaSA(nSgenes,startDAG,D,control)
plot(as(tempRes$maxDAG,"graphNEL"))
control$para <- c(tempRes$typeI,tempRes$typeII)
result <- c(score(list(tempRes$maxDAG),D,control=control, verbose),
list(models = tempRes$graphs, LLscores = tempRes$LLscores,Temperatures = tempRes$Temp, AcceptRates = tempRes$AcceptRate,
minIter = tempRes$minIter, transformAR=tempRes$transformAR, typeIEst = tempRes$typeI, typeIIEst = tempRes$typeII, typeIchain = tempRes$AlphaVals, typeIIchain = tempRes$BetaVals))
plot(result$graph)
pcnema <- nem(D,models=list(Phi),inference="AdaSimAnneal",control=control,verbose=FALSE)
library(pcnem)
pcnema $typeIIEst
View(Idx)
plot(pcnema$graph)
control$iterations
plot(as(Phi,"graphNEL"))
source('~/GitHub/c-NEMs/Package/pcnem/R/AdaSimulatedAnnealing.R')
source('~/GitHub/c-NEMs/Package/pcnem/R/pcNemFunctions.R')
a <- nem.AdaSA(8,Phi,D,control)
plot(as(a$maxDAG,"graphNEL"))
control$iterations
plot(as(Phi,"graphNEL"))
phi <- Phi
for(z in 1:0){ print(i)}
for(z in 1:0){ print(z)}
is.null(control$iterations)
is.zero(control$iterations)
control$iterations==0
library(pcnem)
pcnema <- nem(D,models=list(Phi),inference="AdaSimAnneal",control=control,verbose=FALSE)
plot(pcnema$graph)
control$iterations = 100
pcnema <- nem(D,models=list(Phi),inference="AdaSimAnneal",control=control,verbose=FALSE)
plot(pcnema$graph)
control$iterations = 1000
pcnema <- nem(D,models=list(Phi),inference="AdaSimAnneal",control=control,verbose=FALSE)
plot(pcnema$graph)
control$Temp
control$AdaptRate
control$Temp
load("~/Downloads/NoiseEstimation120_5to50_320_TR_sf100_Temp100.RData")
seq(4,16,by=4)
