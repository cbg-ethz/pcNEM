library(pcnem)
set.seed(456)
n <- 8
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores
source('~/.active-rstudio-document')
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
starttime1a <- proc.time()
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
endtime1a <- proc.time()
library(pcnem)
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
starttime1a <- proc.time()
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
endtime1a <- proc.time()
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
pcnem$graph
plot(pcnem$graph)
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
plot(pcnem$graph)
!is.null(control$Pm) & length(control$lambda) > 1
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
plot(pcnem$graph)
source('~/.active-rstudio-document')
par(mfrow=c(1,2))
plot(pcnem$graph)
plot(rnem$graph)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
set.seed(456)
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
rm(rnem)
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
set.seed(456)
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
load("~/Downloads/SigMat3sd_PublishedGenes_QiagenData.Rdata")
source('~/.active-rstudio-document')
sum(D)
load("~/Downloads/SigMat_PublishedGenes_QiagenData.Rdata")
load("~/Downloads/SignalMat/SigMat_PublishedGenes_QiagenData.Rdata")
sum(D)
source('~/.active-rstudio-document')
shd(as(pcNEM_mat,'graphNEL'),as(Phi,"graphNEL"))
shd(as(rNEM_mat,'graphNEL'),as(Phi,"graphNEL"))
auc(roc(Phi,pcNEM_mat))
auc(roc(Phi,rNEM_mat))
pcnem$typeIEst
pcnem$typeIIEst
load("~/Downloads/SigMat3sd/SigMat3sd_PublishedGenes_QiagenData.Rdata")
load("~/Downloads/SignalMat3sd/SigMat3sd_PublishedGenes_QiagenData.Rdata")
source('~/.active-rstudio-document')
shd(as(pcNEM_mat,'graphNEL'),as(Phi,"graphNEL"))
shd(as(rNEM_mat,'graphNEL'),as(Phi,"graphNEL"))
auc(roc(Phi,pcNEM_mat))
auc(roc(Phi,rNEM_mat))
load("~/Documents/ETH/MasterThesis/Plots/2017/10Mar2017/SignalMat099/SigMat3sd_PublishedGenes_QiagenData.Rdata")
source('~/.active-rstudio-document')
control$mc.cores <- 3
source('~/.active-rstudio-document')
control$noiseEst
?boot::boot
boot::boot(1:nrow(D), inferNetwork, nboot, strata=group, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
use.parallel = "snow"
inferNetwork <- function(idx.orig=1:nrow(D), boot){
controltmp = control
controltmp$Pe = control$Pe[boot,]
Dtmp = D[boot,]
if(!is.null(control$Pm) & length(control$lambda) > 1)
res = as.vector(as(nemModelSelection(control$lambda,Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
else
res = as.vector(as(nem(Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
res
}
nboot=3
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
!is.null(rownames(D)) & "time"  %in% colnames(D)
"snow" %in% loadedNamespaces()
cl <- makeCluster(control$mc.cores, type = "SOCK")
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, strata=group, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
inference = "AdaSimAnneal"
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
models=NULL
models=NULL
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
verbose=FALSE
verbose=TRUE
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
control$mc.cores = 1
use.parallel = "snow"
cl <- makeCluster(control$mc.cores, type = "SOCK")
nboot= 1
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
nboot
res.boot$t
nboot=2
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
res.boot$t
res.boot$seed
res.boot$weights
?boot::boot
!is.null(control$Pm) & length(control$lambda) > 1
npcnem <- nem(D,inference="AdaSimAnneal",control=control,verbose=FALSE)
npcnem$typeIEst
npcnem$typeIIEst
inferNetwork <- function(idx.orig=1:nrow(D), boot){
controltmp = control
controltmp$Pe = control$Pe[boot,]
Dtmp = D[boot,]
if(control$pcombi==TRUE){
restmp = nem(Dtmp,inference,models,controltmp,verbose)
res <- as.vector(as(restmp$graph,"matrix"))
resnoise <- c(restmp$typeIEst, restmp$typeIIEst)
c(res, resnoise)
}else{
if(!is.null(control$Pm) & length(control$lambda) > 1)
res = as.vector(as(nemModelSelection(control$lambda,Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
else
res = as.vector(as(nem(Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
res
}
}
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
res.boot$t
inferNetwork <- function(idx.orig=1:nrow(D), boot){
controltmp = control
controltmp$Pe = control$Pe[boot,]
Dtmp = D[boot,]
if(control$pcombi==TRUE){
restmp = nem(Dtmp,inference,models,controltmp,verbose)
res <- as.vector(as(restmp$graph,"matrix"))
resnoise <- c(restmp$typeIEst, restmp$typeIIEst)
list(res, resnoise)
}else{
if(!is.null(control$Pm) & length(control$lambda) > 1)
res = as.vector(as(nemModelSelection(control$lambda,Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
else
res = as.vector(as(nem(Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
res
}
}
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
rm(res.boot)
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
inferNetwork <- function(idx.orig=1:nrow(D), boot){
controltmp = control
controltmp$Pe = control$Pe[boot,]
Dtmp = D[boot,]
if(control$pcombi==TRUE){
restmp = nem(Dtmp,inference,models,controltmp,verbose)
res <- as.vector(as(restmp$graph,"matrix"))
resnoise <- c(restmp$typeIEst, restmp$typeIIEst)
c(res, resnoise)
}else{
if(!is.null(control$Pm) & length(control$lambda) > 1)
res = as.vector(as(nemModelSelection(control$lambda,Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
else
res = as.vector(as(nem(Dtmp,inference,models,controltmp,verbose)$graph,"matrix"))
res
}
}
res.boot = boot::boot(1:nrow(D), inferNetwork, nboot, parallel=use.parallel, ncpus=control$mc.cores, cl=cl)
res.boot$t
results =  res.boot$t
if(control$pcombi==TRUE){
map<-control$map
Sgenes<-colnames(map)
}else{
Sgenes <- setdiff(unlist(control$map[intersect(names(control$map), colnames(D))]),"time")
}
n = length(Sgenes)
overlapBoot = colMeans(results)
if(control$pcombi==TRUE){
avgNoise <- tail(overlapBoot,2)
overlapBoot = matrix(round(overlapBoot[1:n^2],digits=2),ncol=n,nrow=n)
}else{
overlapBoot = matrix(round(overlapBoot,digits=2),ncol=n,nrow=n)
}
avgNoise
overlapBoot
control$para
control$para <- c(0.123,0.05)
control$para
control$para <- c(0.13,0.05)
avgNoise
pcnem$graph
rnem$graph
rnem$graph
rnem$selected
rnem$control$para
source('~/.active-rstudio-document')
res.all = matrix(0, ncol=nboot, nrow=n^2)
nboot=2
n = 8
res.all = matrix(0, ncol=nboot, nrow=n^2)
library(pcnem)
source('~/.active-rstudio-document')
library(pcnem)
source('~/.active-rstudio-document')
rnem$control$noiseEst
rnem$control$para
pcnem$control$para
pcnem$selected[1]
pcnem$selected[2]
pcnem$selected[3]
pcnem$pos[1]
pcnem$graph
pcnem$mLL
pcnem$mappos[1]
pcnem$mappos[2]
a <- pcnem$mappos
b <- rnem$mappos
a1 <- pcnem$pos
pcnem$mappos
pcnem$control
pcnem$selected
rnem$selected
library(pcnem)
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
set.seed(456)
n <- 8
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
control$lambda != 0 | !("doMC" %in% loadedNamespaces())
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
(overlapBoot>thresh)*1)
(overlapBoot>thresh)*1
models <- list((overlapBoot>thresh)*1)
models[unlist(lapply(models,function(x){diag(x) <- 0
is.DAG(x)}))]
x <- (overlapBoot>thresh)*1)
x <- (overlapBoot>thresh)*1
is.DAG(x)
control$lambda != 0 | !("doMC" %in% loadedNamespaces())
control$lambda != 0 | !("doMC" %in% loadedNamespaces())
res = nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
res$pos
res$selected
res$mappos
control$type
res$LLperGene
sum(res$LLperGene)
type(res$LLperGene)
class(res$LLperGene)
res$mLL
!is.null(control$Pe)
!(control$type %in% c("CONTmLLMAP","CONTmLLRatio", "depn"))
!is.null(control$Pe)
control$Pe
library(pcnem)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
set.seed(456)
n <- 8
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
sum(LLperGene)
map = apply(Theta,1,which)
library(pcnem)
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
mappos=map
mappos
map
!is.null(rownames(D1))
View(D1)
sapply(map, names)
rnem <- nem.bootstrap(D_nem, nboot=5,inference="ModuleNetwork",control=control, verbose=FALSE)
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
sapply(map, names)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
sapply(map, names)
mappos
!is.null(rownames(D1))
library(pcnem)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
rnem$mappos
library(pcnem)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
set.seed(456)
n <- 8
control <- set.default.parameters(unique(colnames(D)),type="mLL",pcombi = TRUE, trans.close=FALSE)
control$map <- as.matrix(KOmap)
control$iterations <- 50
control$mc.cores <- 2
pcnem <- nem.bootstrap(D,nboot = 3,inference="AdaSimAnneal",control=control,verbose=FALSE)
nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
models=list((overlapBoot>thresh)*1)
inference="search"
verbose = FALSE
if (is.null(models)) models <- enumerate.models(length(Sgenes),Sgenes,trans.close=control$trans.close,verbose=verbose)
models[unlist(lapply(models,function(x){diag(x) <- 0
is.DAG(x)}))
]
score(models,D,control,verbose)
class(models)=="matrix"
map<-control$map
nexp<-rownames(map)
Sgenes<-colnames(map)
nrS <- length(Sgenes)
fkt <- function(x,s){
ss <- sort(s)
c1 <- all(sort(setdiff(colnames(x), "unknown"))==ss)
c2 <- all(sort(setdiff(rownames(x), "unknown"))==ss)
return(c1 & c2)
}
!all(sapply(models,fkt,s=Sgenes))
control$pcombi== TRUE
length(nexp) != ncol(D)
control$type %in% c("mLL", "FULLmLL")
control$pcombi==TRUE
D1 = sapply(nexp, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))  #Sgenes
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1
is.null(control$Pe)
control$Pe <- matrix(1/nrS,nrow=NROW(D1),ncol=nrS)
colnames(control$Pe) <- Sgenes
"unknown" %in% colnames(models[[1]])
control$selEGenes.method == "regularization" && ncol(control$Pe) == nrS
control$Pe = cbind(control$Pe, double(nrow(D1)))
control$Pe[,ncol(control$Pe)] = control$delta/nrS
control$Pe = control$Pe/rowSums(control$Pe)
colnames(control$Pe)[ncol(control$Pe)] = "null"
is.null(control$Pm) & (control$lambda != 0)
control$lambda != 0
sapply(models,mLL,D1,D0,control, verbose)
sapply(models,mLL,D1,D0,control, verbose)
results <- sapply(models,mLL,D1,D0,control, verbose)
results["mappos",]
load("~/Downloads/Pub/PublishedGenes_QiagenData_wInv.Rdata")
library(pcalg)
library(pROC)
library(pcnem)
D_nem <- D
colnames(D_nem) <- siRNA_gene_Expts[,2]
#control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=TRUE)
control <- set.default.parameters(unique(colnames(D_nem)),type="mLL",pcombi = FALSE,trans.close=FALSE)
control$mc.cores <- 3
rnem <- nem.bootstrap(D_nem, nboot=10,inference="ModuleNetwork",control=control, verbose=FALSE)
models=list((overlapBoot>thresh)*1)
inference="search"
#if single model as input
if (class(models)=="matrix") models <- list(models)
# Which Sgenes were silenced?
if(control$pcombi== FALSE){
Sgenes <- setdiff(unlist(control$map[intersect(names(control$map), colnames(D))]),"time")
nrS <- length(Sgenes)
}else{
map<-control$map
nexp<-rownames(map)
Sgenes<-colnames(map)
nrS <- length(Sgenes)
}
# check that all models have S-genes as names
fkt <- function(x,s){
ss <- sort(s)
c1 <- all(sort(setdiff(colnames(x), "unknown"))==ss)
c2 <- all(sort(setdiff(rownames(x), "unknown"))==ss)
return(c1 & c2)
}
if (!all(sapply(models,fkt,s=Sgenes))) stop("\nnem:score> models must have same names as data")
if (control$pcombi== TRUE){
if(length(nexp) != ncol(D)){
stop("\nnem:score> the number of experiments in KO map do not match with the data")
}
}
#nrS <- length(Sgenes)
# make probability/density matrices D0 and D1
# nrow=#E-genes and ncol=#S-genes
if(control$type %in% c("mLL", "FULLmLL")){
if(control$pcombi==TRUE){
D1 = sapply(nexp, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))  #Sgenes
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1
}else{
D1 = sapply(Sgenes, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))
D0 = sapply(Sgenes, function(s) sum(colnames(D) == s)) - D1
}
}else{
D1 = D
D0 = NULL
}
# if no prior is supplied:
# assume uniform prior over E-gene positions
if (is.null(control$Pe)){
control$Pe <- matrix(1/nrS,nrow=NROW(D1),ncol=nrS)
colnames(control$Pe) <- Sgenes
}
if("unknown" %in% colnames(models[[1]])){
control$Pe = cbind(control$Pe, 1/nrS)
control$Pe = control$Pe/rowSums(control$Pe)
colnames(control$Pe)[ncol(control$Pe)] = "unknown"
}
if(control$selEGenes.method == "regularization" && ncol(control$Pe) == nrS){
control$Pe = cbind(control$Pe, double(nrow(D1)))
control$Pe[,ncol(control$Pe)] = control$delta/nrS
control$Pe = control$Pe/rowSums(control$Pe)
colnames(control$Pe)[ncol(control$Pe)] = "null"
}
if(is.null(control$Pm) & (control$lambda != 0)){
cat(">>> Regularization parameter non-zero: Generating sparsity prior automatically! <<<\n")
control$Pm = diag(length(Sgenes))
}
control$pcombi== FALSE
Sgenes <- setdiff(unlist(control$map[intersect(names(control$map), colnames(D))]),"time")
nrS <- length(Sgenes)
nrS
fkt <- function(x,s){
ss <- sort(s)
c1 <- all(sort(setdiff(colnames(x), "unknown"))==ss)
c2 <- all(sort(setdiff(rownames(x), "unknown"))==ss)
return(c1 & c2)
}
if (!all(sapply(models,fkt,s=Sgenes))) stop("\nnem:score> models must have same names as data")
if (control$pcombi== TRUE){
if(length(nexp) != ncol(D)){
stop("\nnem:score> the number of experiments in KO map do not match with the data")
}
}
#nrS <- length(Sgenes)
# make probability/density matrices D0 and D1
# nrow=#E-genes and ncol=#S-genes
if(control$type %in% c("mLL", "FULLmLL")){
if(control$pcombi==TRUE){
D1 = sapply(nexp, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))  #Sgenes
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1
}else{
D1 = sapply(Sgenes, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))
D0 = sapply(Sgenes, function(s) sum(colnames(D) == s)) - D1
}
}else{
D1 = D
D0 = NULL
}
control$type %in% c("mLL", "FULLmLL")
if(control$pcombi==TRUE){
D1 = sapply(nexp, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))  #Sgenes
D0 = sapply(nexp, function(s) sum(colnames(D) == s)) - D1
}else{
D1 = sapply(Sgenes, function(s) rowSums(D[,colnames(D) == s,drop=FALSE]))
D0 = sapply(Sgenes, function(s) sum(colnames(D) == s)) - D1
}
rnem <- nem.bootstrap(D_nem, nboot=5,inference="ModuleNetwork",control=control, verbose=FALSE)
res = nem(D,models=list((overlapBoot>thresh)*1),inference="search",control, verbose=verbose)
res$mappos[[1]]
